# Use cases

## Create a dependency hierarchy

In larger projects, it can be helpful to create a logical hierarchy for package dependencies.
This structure can help guide developers toward a clean separation of concerns.

```ts filename="commonality.config.ts"
import { defineConfig } from 'commonality';

export default defineConfig({
  constraints: {
    '*': {
      disallow: ['deployable'],
    },
    deployable: {
      allow: ['ui', 'data', 'utility', 'config'],
    },
    ui: {
      allow: ['utility', 'config'],
    },
    state: {
      allow: ['utility', 'config'],
    },
    data: {
      allow: ['utility', 'config'],
    },
    utility: {
      allow: ['utility', 'config'],
    },
    config: {
      disallow: '*',
    },
  },
});
```

## Create private local packages

Limit packages to a specific business vertical and explicitly tag packages as `shared` to allow their use across teams.

```ts filename="commonality.config.ts"
import { defineConfig } from 'commonality';

export default defineConfig({
  constraints: {
    '*': {
      allow: ['shared'],
    },
    commerce: {
      allow: ['commerce'],
    },
    marketing: {
      allow: ['marketing'],
    },
  },
});
```
