import { Callout } from 'nextra/components';

# Creating checks

Checks are defined in the configuration file at the root of your project. You can use matchers to run checks against all the packages in your project or a subset of packages.

## Creating your first check

All checks have three required properties:

1. [**`name`**](/docs/api/checks#name) A unique identifier for the check, we use this to parallelize checks and prevent write collisions.

2. [**`validate`**](/docs/api/checks#validate) A function that should return either a truthy or falsey value indicating whether or not the check is valid.

3. [**`message`**](/docs/api/checks#message) A string or function that that provides more context about the check.

<Callout type="info">
  You can view all available check properties and more examples in our
  [reference documentation](/docs/reference/checks).
</Callout>

Here's an example of a simple check that ensures every package has at least one codeowner.

```ts filename="commonality.config.ts"
import { defineConfig } from 'commonality';

export default defineConfig({
  checks: {
    '*': [
      {
        name: 'ensure-codeowner',
        validate: (ctx) => ctx.codeowners.length > 0,
        message: 'Packages must have at least one codeowner',
      },
    ],
  },
});
```

We can run this check with

```bash copy
commonality check
```

## Auto-fixable checks

It's great to be notified that something isn't right, but it's even better when you can fix it with a single key press.

To make a check fixable just add a [`fix`](/docs/api/checks#fix) property to your check. This function will only run against the package if the result of [`validate`](/docs/api/checks#validate) is falsey.

Here's an example of a check that will automatically create a `README.md` for a package if it does not exist.

```ts filename="commonality.config.ts"
import { defineConfig } from 'commonality';
import { json, text } from 'commonality/checks';

export default defineConfig({
  checks: {
    '*': [
      {
        name: 'ensure-readme',
        validate: async (ctx) => {
          return text(ctx.package.path, 'README.md').exists();
        },
        fix: async (ctx) => {
          // Get the contents of the package.json file
          const packageJson = await json(
            ctx.package.path,
            'package.json',
          ).get();

          if (!packageJson) {
            return;
          }

          // Create a README.md with some basic content about the package
          await text(ctx.package.path, 'README.md').set([
            `# ${packageJson.name}`,
            `> ${packageJson.description}`,
          ]);
        },
        message: `Package must have a README.md file`,
      },
    ],
  },
});
```

## Customizing messages

Messages can be provided as a string for simple checks or constructed dynamically using a function that is passed [`CheckContext`](/docs/api/checks#checkcontext) and returns a [`Message`]((/docs/api/checks#message-1)) object.

### Static message

You can provide a string as the message, this is useful for checks that don't require much context or have a single way of failing.

```ts
import { defineCheck } from 'commonality/checks';

const hasCodeowner = defineCheck(() => {
  return {
    // ...
    message: 'Every package must have at least one codeowner',
  };
});
```

The following output will be shown when running the check:

```
✓ warn Every package must have at least one codeowner
```

### Dynamic message

Sometimes you'll want to provide more context or account for multiple ways a check can fail.
You can return a [`Message`](/docs/api/checks#message-1) object from the [`message`](/docs/api/checks#message) function to dynamically construct the output shown below.

```ts
import { defineCheck, json, diff } from 'commonality/checks';
import path from 'node:path';

const ensureTSConfigExtends = defineCheck((base: string) => {
  return {
    // ...
    message: async (ctx) => {
      const tsConfig = await json(ctx.package.path, 'tsconfig.json').get();

      if (!tsConfig) {
        return {
          text: 'tsconfig.json does not exist',
          filePath: 'tsconfig.json',
        };
      }

      return {
        text: `tsconfig.json must extend ${base}`,
        filePath: 'tsconfig.json',
        suggestion: diff(tsConfig, { ...tsConfig, extends: base }),
      };
    },
  };
});
```

Use the [`diff`](/docs/api/checks#diff) utility to suggest file edits needed to pass checks. The `suggestion` property is also useful for showing how a [`fix`](/docs/api/checks#fix) function will modify a file.

The [`diff`](/docs/api/checks#diff) function will return a pretty printed string where unique properties and values in the second argument appear in red and are prefixed with `+`."

The following output will be shown when running the check above:

```
✓ warn Every package must have at least one codeowner
|      packages/pkg-a/tsconfig.json
│        Object {
│            "include": ["./src/**/*.ts", "./src/**/*.tsx"]
│      +     "extends": "@scope/tsconfig/react",
│        }
```

## Composing checks

While basic checks go a long way, you may want to pass options to your checks to make them re-usable in a variety of different scenarios.

Instead of defining checks as an object you can use our [`defineCheck`](/docs/api/checks#definecheck) helper to define checks as functions, allowing you to dynamically pass options to checks.

Here's an example of a configuration that ensures that all packages with the tag `buildable` have `build` and `dev` scripts.

```ts filename="commonality.config.ts"
import { defineConfig, defineCheck } from 'commonality';

const ensureScript = defineCheck((scriptName: string, value: string) => ({
  name: 'ensure-script',
  validate: (ctx) => {
    const packageJson = json(ctx.package.path, 'package.json').get();

    if (!packageJson) {
      return false;
    }

    return packageJson.scripts && packageJson.scripts[scriptName];
  },
  fix: (ctx) => {
    return json(ctx.package.path, 'package.json').merge({
      scripts: {
        [scriptName]: value,
      },
    });
  },
}));

export default defineConfig({
  checks: {
    buildable: [
      ensureScript('build', 'tsc'),
      ensureScript('dev', 'tsc --watch'),
    ],
  },
});
```

