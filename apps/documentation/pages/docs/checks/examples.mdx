import { Callout } from 'nextra/components';

## Examples

We believe that Commonality's strength lies in the ability to easily create powerful conformance tests.
While you can enforce almost anything we wanted to examples to spark inspiration for what you might build checks for.

### Check that a package has a CODEOWNER

The `validate`, `fix`, and `message` functions are all passed a `CheckContext` object that contains metadata about the package the check is being run against.
We can use the `codeowners` property to check if the package is covered by a pattern [in the project's CODEOWNERS file](/docs/project-metadata#codeowners).

#### Example

```ts
import { defineCheck } from 'commonality';

const hasCodeowner = defineCheck({
  name: 'has-codeowner',

  message: 'Package must have a CODEOWNER',

  validate: async ({ codeowners }) => codeowners.length,
});
```

#### Usage

```ts filename="commonality.config.ts"
export default defineConfig({
  checks: {
    '*': [hasReadme()],
  },
});
```

### Check that a package has a `README.md`

#### Example

```ts
import { defineCheck, text, json } from 'commonality';

const hasReadme = defineCheck(() => ({
  name: 'ensure-readme',

  validate: async ({ workspace }) => {
    return text(workspace.path, 'README.md').exists();
  },

  fix: async ({ workspace }) => {
    const packageJson = await json<PackageJson>(
      workspace.path,
      'package.json',
    ).get();

    if (!packageJson) {
      return;
    }

    await text(workspace.path, 'README.md').set([
      `# ${packageJson.name}`,
      `> ${packageJson.description}`,
    ]);
  },

  message: `Package must have a README.md`,
}));
```

#### Usage

```ts filename="commonality.config.ts"
export default defineConfig({
  checks: {
    '*': [hasReadme()],
  },
});
```

### Check that a package has certain NPM scripts

#### Example

```ts
import { defineCheck, json, diff } from 'commonality';

const hasScript = defineCheck((name: string, value: string) => ({
  name: 'ensure-script',

  validate: async ({ workspace }) => {
    const packageJson = json(workspace.path, 'package.json').get();

    return packageJson.scripts?.[name] === value;
  },

  fix: async ({ workspace }) => {
    const packageJson = await json(workspace.path, 'package.json').get();

    if (!packageJson) {
      return;
    }

    await text(workspace.path, 'README.md').merge({
      scripts: {
        [name]: value,
      },
    });
  },

  message: ({ workspace }) => {
    const packageJson = await json(workspace.path, 'package.json').get();

    return {
      title: `Package must have a "${name}" script with value "${value}"`,
      filePath: 'package.json',
      // Provide a diff for better contextual information when the check fails
      suggestion: diff(packageJson.scripts, { scripts: { [name]: value } }),
    };
  },
}));
```

#### Usage

<Callout type="info" emoji="ðŸ’¡">
  Creating checks that accept arguments makes them reusable in a variety of that
  can be composed together.
</Callout>

```ts filename="commonality.config.ts"
export default defineConfig({
  checks: {
    buildable: [
      hasScript('build', 'tsc'),
      hasScript('dev', 'tsc --watch'),
      hasScript('clean', 'rimraf dist'),
    ],
  },
});
```

### Check that a package extends a certain base config

#### Example

#### Usage
