Checks are best created using the `defineCheck` function and are passed to the `checks` property in you [project's configuration](/sdk/configuration#projectconfiguration). This function will
provide type-safety and intellisense for properties.

```ts
const check = {
  name: 'my-team/my-check',
  validate: () => {},
  fix: () => {},
  message: 'My check failed',
};
```

## Properties

<ResponseField name="name" type="string" required>
A unique identifier for the check. This will be
used to parallelize checks and prevent write conflicts when running fix functions.

<Info>When creating sharable checks, we recommend using a namespace to prevent naming conflicts. i.e. `@scope/`, `my-team/`</Info>


```ts
import { defineCheck } from 'commonality';

const hasCodeowner = defineCheck(() => {
  return {
    // ...
    name: 'my-team/ensure-codeowner',
  };
});
```

</ResponseField>



<ResponseField name="message" type={`"string" | (options: CheckContext) => Message | Promise<Message>`} required>

**Static message**

Set `message` to a string to provide a static message for your check.

```ts
import { defineCheck } from 'commonality';

const hasCodeowner = defineCheck(() => {
  return {
    // ...
    message: 'Package must have a codeowner',
  };
});
```

**Dynamic message**

Set `message` to a function to provide a dynamic message for your check.


**Returns**
<ResponseField name="message" type="Message">
  <Expandable title="properties">
    <ResponseField name="suggestion" type="string">
      The full name of the user
    </ResponseField>

    <ResponseField name="is_over_21" type="boolean">
      Whether the user is over 21 years old
    </ResponseField>
  </Expandable>
</ResponseField>

```ts
import { defineCheck } from 'commonality';

const hasCodeowner = defineCheck(() => {
  return {
    // ...
    message: 'Package must have a codeowner',
  };
});
```

</ResponseField>


---

### `validate`

<Subtext requirementLevel="required">
`"string" | (options: CheckContext) => ValidationResult | Promise<ValidationResult>{:ts}`
</Subtext>

If set to `"error"`, the CLI will exit with a non-zero exit code if the `validate` function returns a falsey value. Default is `"warning"`.

The `validate` function is the primary mechanism for determining if a package is valid or not and will run against all packages in your project.
A returned truthy value will be considered a `pass`, while a falsy value will mark the check as `warn` or `fail` based on the configured [level](#level).

```ts
import { defineCheck } from 'commonality';

const hasCodeowner = defineCheck(() => {
  return {
    // ...
    validate: ({ codeowners }) => codeowners.length,
  };
});
```

---

### `fix`

<Subtext>
`(options: CheckContext) => void | Promise<void>{:ts}`
</Subtext>

A check's `fix` function will only run on packages that where the check's [validate](#validate) has returned a falsey value. This function should update packages so that they pass the check's [validate](#validate) function.

<Callout type="info">
  We provide helper utilities like [`json`](#json) and [`text`](#text) to make
  it easier to read and write to files in `fix` functions.
</Callout>

```ts
import { defineCheck, json } from 'commonality';

const ensureTSConfigExtends = defineCheck((base: string) => {
  return {
    // ...
    fix: async (ctx) => {
      const tsConfig = await json(ctx.package.path, 'tsconfig.json').get();

      if (!tsConfig) {
        return;
      }

      await tsConfig.merge({ extends: base });
    },
  };
});
```

---

### `level`

<Subtext>
`"warning" | "error"{:ts}`
</Subtext>

If set to `"error"`, the CLI will exit with a non-zero exit code if this check is ever invalid. Default is `"warning"`.

## Utilities


### `defineCheck`

`(check: () => Check) => () => Check{:ts}`

This utility provides type-safety and intellisense for check options.
Checks are not required to be wrapped with this utility, however doing so will provide a better developer experience and encourage re-usable checks.

**Example:**

```ts
import { defineCheck } from 'commonality';

const hasCodeowner = defineCheck(() => {
  return {
    // ...
  };
});
```

---

### `createTestCheck`

`(check: Check, context?: TestCheckContext) => Check{:ts}`

`createTestCheck` wraps your checks and decorates these functions with sensible defaults for [CheckContext](/sdk/checks#checkcontext) that you can override.
This cuts down on repetitive boilerplate when writing tests for your checks.

**Parameters**

`check`

<Subtext requirementLevel="required">
`Check{:ts}`
</Subtext>
A valid [check](/sdk/checks#check-properties) object

`context`

<Subtext>
`TestCheckContext{:ts}`
</Subtext>
Pass options that will be used as the check's [`CheckContext`](/sdk/checks#checkcontext).
If a property is not explicitly passed, the check will be passed a default from the table below.

| Name                  | Default                                   |
| :-------------------- | :---------------------------------------- |
| `context.tags`        | `[]{:ts}`                                 |
| `context.codeowners`  | `[]{:ts}`                                 |
| `context.package`     | `{relativePath: './', path: './'}{:ts}`   |
| `context.rootPackage` | `{relativePath: './', path: './'}{:ts}`   |
| `context.allPackages` | `[{relativePath: './', path: './'}]{:ts}` |

**Returns**
Returns the original check function, however the `validate`, `fix`, and `message` functions
will be passed the `TestCheckContext` rather than requiring that `CheckContext` be passed.

**Example**

```ts
// Without createTestCheck
test('validate - returns true when valid', () => {
  mockFs({
    'package.json': JSON.stringify({
      name: 'foo',
      description: 'bar',
    }),
  });

  const check = myCheck();
  const result = myCheck.validate({
    package: {
      path: './',
      relativePath: './',
    },

    allPackages: [
      {
        path: './',
        relativePath: './',
      },
    ],
    codeowners: [],
    tags: [],
  });

  expect(result).toEqual(true);
});

// With createTestCheck
test('validate - returns true when valid', () => {
  mockFs({
    'package.json': JSON.stringify({
      name: 'foo',
      description: 'bar',
    }),
  });

  const check = createTestCheck(myCheck());
  const result = myCheck.validate();

  expect(result).toEqual(true);
});
```

---

## Types

### `CheckContext`

The `validate`, `fix`, and `message` functions are all passed a `CheckContext` object that contains metadata about the package the check is being run against.
The [`codeowners`](/codeowners) and [`tags`](/tags) that correspond to the package are also included.

```ts
type CheckContext = {
  package: {
    path: string;
    relativePath: string;
  };
  allPackages: {
    path: string;
    relativePath: string;
  }[];
  rootPackage: {
    path: string;
    relativePath: string;
  };
  codeowners: string[];
  tags: string[];
};
```

### `Message`
If [`message`](#message) is declared as a function, it must return a [`Message`]() object.
```ts
type Message = {
  text: string;
  filePath?: string;
  suggestion?: string;
};
```
