---
title: 'Creating checks'
icon: 'screwdriver-wrench'
---

Checks can created to standardize any existing configuration or workflow.
Checks can be exported as check objects for simple use cases or as functions that return check objects to make them composable.

## Creating your first check

Checks have two required properties:

1. `message`: The default message that will be shown for the check in the CLI and Commonality Studio
2. `validate`: A function that returns a boolean or a promise that resolves to a boolean. This function is used to determine if the check passes or fails.


<Tabs>
<Tab title="TypeScript">
```ts .commonality/has-codeowner.ts
import type { Check } from 'commonality';

export default {
  message: 'Package has least one codeowner',
  validate: (ctx) => ctx.codeowners.length > 0,
} satisfies Check;
```
</Tab>
<Tab title="JavaScript">
```js .commonality/has-codeowner.js
export default {
  message: 'Package has least one codeowner',
  validate: (ctx) => ctx.codeowners.length > 0,
};
```
</Tab>
</Tabs>

In the check above we're accessing metadata available to the check

## Auto-fixable checks

Failures are helpful but add friction to developer workflows. To solve this, checks can automatically fix themselves.
This makes it easy for teams to adhere to best practices.

To make a check fixable just add a [fix](/reference/check-object#fix) property to your check. This function will only run against a package if the result of [validate](/reference/check-object#validate) is falsey.

Here's an example of a check that will automatically create a `README.md` for a package if it does not exist.

```json .commonality/config.json
import { defineConfig } from 'commonality';
import { json, text } from 'commonality';

export default defineConfig({
  checks: {
    '*': [
      {
        name: 'ensure-readme',
        validate: async (ctx) => {
          return text(ctx.package.path, 'README.md').exists();
        },
        fix: async (ctx) => {
          // Get the contents of the package.json file
          const packageJson = await json(
            ctx.package.path,
            'package.json',
          ).get();

          if (!packageJson) {
            return;
          }

          // Create a README.md with some basic content about the package
          await text(ctx.package.path, 'README.md').set([
            `# ${packageJson.name}`,
            `> ${packageJson.description}`,
          ]);
        },
        message: `Package must have a README.md file`,
      },
    ],
  },
});
```

We provide utilities like [json](/reference/check-object#json), and [text](/reference/check-object#text) to make it easy to read and write files within checks.

## Customizing messages

Messages can be provided as a string for simple checks or constructed dynamically using a function that is passed [CheckContext](/reference/check-object#checkcontext) and returns a Message object.

### Static message

You can provide a string as the message, this is useful for checks that don't require much context or have a single way of failing.

```ts
import { defineCheck } from 'commonality';

const hasCodeowner = defineCheck(() => {
  return {
    // ...
    message: 'Every package must have at least one codeowner',
  };
});
```

The following output will be shown when running the check:

```
✓ warn Every package must have at least one codeowner
```

### Dynamic message

Sometimes you'll want to provide more context or account for multiple ways a check can fail.
You can return a [Message](/reference/check-object#message-1) object from the [message](/reference/check-object#message) function to dynamically construct the output shown below.

```ts
import { defineCheck, json, diff } from 'commonality';
import path from 'node:path';

const ensureTSConfigExtends = defineCheck((base: string) => {
  return {
    // ...
    message: async (ctx) => {
      const tsConfig = await json(ctx.package.path, 'tsconfig.json').get();

      if (!tsConfig) {
        return {
          text: 'tsconfig.json does not exist',
          filePath: 'tsconfig.json',
        };
      }

      return {
        text: `tsconfig.json must extend ${base}`,
        filePath: 'tsconfig.json',
        suggestion: diff(tsConfig, { ...tsConfig, extends: base }),
      };
    },
  };
});
```

Use the [diff](/reference/check-object#diff) utility to suggest file edits needed to pass checks. The `suggestion` property is also useful for showing how a [fix](/reference/check-object#fix) function will modify a file.

The [diff](/reference/check-object#diff) function will return a pretty printed string where unique properties and values in the second argument appear in red and are prefixed with `+`."

The following output will be shown when running the check above:

```
✓ warn Every package must have at least one codeowner
|      packages/pkg-a/tsconfig.json
│        Object {
│            "include": ["./src/**/*.ts", "./src/**/*.tsx"]
│      +     "extends": "@scope/tsconfig/react",
│        }
```

## Composing checks

Since checks are just functions, you can create checks that accept arguments to make them re-usable in a variety of different scenarios.

As an example, below is the source code for our [hasJsonFile](/examples/recommended-checks#has-json-file) utility check.

```json .commonality/config.json
import { defineCheck, json, diff } from 'commonality';
import isMatch from 'lodash-es/isMatch';

export const hasJsonFile = defineCheck(
  (fileName: string, content?: Record<string, unknown>) => {
    return {
      name: 'commonality/has-json-file',
      level: 'error',
      message: async (ctx) => {
        const jsonFile = await json(ctx.package.path, fileName).get();

        if (!jsonFile) return { title: `File "${fileName}" does not exist` };

        if (content && !isMatch(jsonFile, content)) {
          return {
            title: `"${fileName}" does not contain expected content`,
            suggestion: diff(jsonFile, content),
          };
        }

        return { title: `${fileName} exists` };
      },
      validate: async (ctx) => {
        const jsonFile = await json(ctx.package.path, fileName).get();

        if (!jsonFile) return false;

        if (!content) return true;

        return isMatch(jsonFile, content);
      },
      fix: async (ctx) => {
        if (!content) return;

        await json(ctx.package.path, fileName).merge(content);
      },
    };
  },
);

```
