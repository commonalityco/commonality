---
title: "Tags"
icon: "tags"
---

Tags are used to selectively apply [checks](/checks/introduction) and [constraints](/constraints/introduction) to packages.

Tags are defined in a [package configuration](/reference/package-configuration) file located in your package's root directory.

```json commonality.json
{
  "tags": ["ui", "buildable", "private", "beta"]
}
```

Tags allow you to group packages by their purpose, concern, or domain without a tight coupling to directory structure.

Below are some examples for inspiration but tags can be used to create any grouping that best suits your project.

## Tooling

Tags can be used to enforce a consistent toolchain for subsets of packages.

**Examples:**

- Check that packages with the `buildable` tag have `build` and `dev` scripts.
- Check that packages with the `testable` tag have a `test` script and a `vitest.config.ts` file.
- Check that packages with the `typed` tag have `typescript` as a devDependency.

## Concern

Tags can be used to create a hierarchy of packages based on their concern.

**Examples:**

- Enforce that no package can depend on a package with the tag `deployable`.
- Enforce that packages with the tag `config` can only depend on packages also with the tag `config`.
- Enforce that a database utility package with the tag `data` cannot depend on packages with the tag `ui`.

## Domain

Tags can be used to create separation between teams or domains working in the same monorepo.

- Limit that packages with the tag `marketing` can only depend on packages with the tag `marketing` or `shared`.

## Workflow

Tags can be used to create workflows like deprecating or creating beta warnings.

- Enforce that packages with the tag `high-stability` cannot depend on package with the tag `beta`.
- Enforce that no package can depend on a package with the tag `deprecated`.
